/** 
 * @module JSPraat 
 * @global
 */
var JSPraat = {};


//------------------------------------------------------------------------------------------------------
//--------------------------------START OF TEXTGRID-----------------------------------------------------
//------------------------------------------------------------------------------------------------------

/**
 * A TextGrid parses and represents a
 * a TextGrid file generated by Praat.
 * At the moment, it only supports the long-form
 * format TextGrids.
 *
 * @class TextGrid
 * @memberOf JSPraat
 * @constructor
 * @param {string} data A String that is either a URL to the Data or the Data itself
 * @param {function} readyFunc The ready function
 */
JSPraat.TextGrid = function(data, readyFunc) {
	if (! (this instanceof JSPraat.TextGrid) ) {
		return new JSPraat.TextGrid(data);
	}

	var pathRegex = /^.+\.TextGrid$/i;
	var match;
	var self = this;

	this.readyFunc = readyFunc;

	if( (match = data.match(pathRegex)) ) {
		$.ajax({
			url: data,
			// beforeSend: function( xhr ) {
			// 	// Note: Server should send file with correct charset header
			// 	// You cannot rely upon a dumb-static server
			// 	// xhr.overrideMimeType("text/plain; charset=utf-16be");
			// }
		}).done(function(value) {
			// console.log(value);
			self.initializeFromData(value);
		});
	} else {
		this.initializeFromData(data);
	}
};

/**
 * @method initializeFromData
 * @param {string} data A String containing the TextGrid Data
 * @private
 */
JSPraat.TextGrid.prototype.initializeFromData = function (data) {
	this.lines = data.split('\n');
	this.header = {
		fileType: null,
		objectClass: null,
		xmin: null,
		xmax: null,
		tiersExist: false,	//translates to 'tiers? <exist>'
		numberOfTiers: 0,	//translates to just 'size'
	};
	this.startingLineIndexOfTiers = -1;
	this.tiers = [];

	this.parseHeader();
	this.checkHeader();
	this.parseTiers();


	if(typeof this.readyFunc === 'function') {
		this.readyFunc();
	}
};

/**
 * Sets the ready callback for TextGrids
 * @method ready
 * @public
 * @param {Function} func callback function
 */
JSPraat.TextGrid.prototype.ready = function(func) {
	if(typeof func !== 'function') {
		throw "TextGrid ready requires a function";
	}
	this.readyFunc = func;
};
/**
 * @method checkHeader
 * @private
 */
JSPraat.TextGrid.prototype.checkHeader = function() {
	if(this.tiersExist === false) { 
		throw "Invalid TextGrid Header: Tiers do not exist";
	}
	if(this.startingLineIndexOfTiers < 0) { 
		throw "Invalid TextGrid Header: startingLineIndexOfTiers Not Found";
	}
};

/**
 * @method parseTiers
 * @private
 */
JSPraat.TextGrid.prototype.parseTiers = function() {
	var tierStartRegex = /^\s+item\s+\[(\d+)\]\:/i;
	var match;
	var inTier = null;

	var startIndex = 0;
	var endIndex = 0;
	for(var i = this.startingLineIndexOfTiers; i < this.lines.length; i++) {
		if( (match=this.lines[i].match(tierStartRegex)) ) {
			if(inTier > 0) {
				// console.log('[', startIndex, ', ', endIndex, ']');
				this.tiers.push(new JSPraat.TextGrid.Tier(this.lines.slice(startIndex, endIndex)));
			}
			inTier = parseInt(match[1]);
			startIndex = i+1;
			endIndex = i+1;
		}
		if(inTier > 0) {
			endIndex++;
		}
	}
	// console.log('final tier ');
	// console.log('[', startIndex, ', ', endIndex, ']');
	this.tiers.push(new JSPraat.TextGrid.Tier(this.lines.slice(startIndex, endIndex)));
};

JSPraat.TextGrid.prototype.parseHeader = function() {
	//MARKED FOR CHANGE: this prevents zero tier TextGrid files, fix later
	var endOfHeaderRegex = /^\s*item\s*\[.+\]\:/i; 
	var xminRegex = /^xmin\s*=\s*([\d\.]+)/i;
	var xmaxRegex = /^xmax\s*=\s*([\d\.]+)/i;
	var tiersExistRegex = /^tiers\?\s*(<exists>)/i;
	var numberOfTiersRegex = /^size\s*=\s*(\d+)/;
	var fileTypeRegex = /^File type\s*=\s*\"(\w+)\"/i;
	var objectClassRegex = /^Object class\s*=\s*\"(\w+)\"/i;

	var match;
	for(var i = 0; i < this.lines.length; i++) {
		if(this.lines[i].match(endOfHeaderRegex)) {
			this.startingLineIndexOfTiers = i;
			break;
		}

		if( (match=this.lines[i].match(xminRegex)) ) {
			this.header.xmin = parseFloat(match[1]);
		}
		else
		if( (match=this.lines[i].match(xmaxRegex)) ) {
			this.header.xmax = parseFloat(match[1]);
		}
		else
		if( (match=this.lines[i].match(tiersExistRegex)) ) {
			this.header.tiersExist = true;
		}
		else
		if( (match=this.lines[i].match(numberOfTiersRegex)) ) {
			this.header.numberOfTiers = parseInt(match[1]);
		}
		else
		if( (match=this.lines[i].match(fileTypeRegex)) ) {
			this.header.fileType = match[1];
		}
		else
		if( (match=this.lines[i].match(objectClassRegex)) ) {
			this.header.objectClass = match[1];
		}
	}
};


//------------------------------------------------------------------------------------------------------
//--------------------------------START OF TEXTGRID/TIER------------------------------------------------
//------------------------------------------------------------------------------------------------------

/**
 * A wrapper class representing a single tier of a TextGrid
 *
 * @class TextGrid.Tier
 * @memberOf JSPraat.TextGrid
 * @constructor
 * @param {Array.<string>} linesArray An array of lines pertaining to that tier
 */
JSPraat.TextGrid.Tier = function(linesArray) {
	if (! (this instanceof JSPraat.TextGrid.Tier) ) {
		return new JSPraat.TextGrid.Tier(linesArray);
	}
	this.lines = linesArray; this.lines.pop();
	this.header = {
		classname: null,
		name: null,
		xmin: null,
		xmax: null,
		numberOfIntervals: null,
		numberOfPoints: null,
	};
	this.startingLineIndexOfBody = null;
	this.parseHeader();
	this.checkHeader();

	if(this.header.classname === 'IntervalTier') {
		this.intervals = [];
		this.parseIntervals();
	}
	else
	if(this.header.classname === 'TextTier') {
		this.points = [];
		this.parsePoints();
	}
	else {
		throw "Invalid Tier Header: "+ this.header.classname + ' is not an acceptable classname';
	}
};
/**
 * @method checkHeader
 * @private
 */
JSPraat.TextGrid.Tier.prototype.checkHeader = function() {
	if(! this.header.classname ) {
		throw "Invalid Tier Header: classname is missing";
	}
	if(! this.header.name) {
		throw "Invalid Tier Header: name is missing";
	}
	if(! this.header.xmin ) {
		throw "Invalid Tier Header: xmin is missing";
	}
	if(! this.header.xmax ) {
		throw "Invalid Tier Header: xmax is missing";
	}
	if(this.header.numberOfIntervals === null && this.header.numberOfPoints === null) {
		throw "Invalid Tier Header: not an interval or point tier.";
	}
	if(this.isIntervalTier() && this.header.numberOfIntervals === null) {
		throw "Invalid Tier Header: classname mismatch. says interval tier but has points size";
	}
	if(this.isPointTier() && this.header.numberOfPoints === null) {
		throw "Invalid Tier Header: classname mismatch. says point tier but has intervals size";
	}
	if(this.header.numberOfPoints !== null && this.header.numberOfIntervals !== null) {
		throw "Invalid Tier Header: header cannot contain both points size and intervals size";
	}
};
/**
 * Returns true if the tier is an Interval Tier
 * @method isIntervalTier
 * @public
 */
JSPraat.TextGrid.Tier.prototype.isIntervalTier = function() {
	if(this.header.classname === 'IntervalTier') {
		return true;
	}
	return false;
};
/**
 * Returns true if the tier is a Point Tier
 * @method isPointTier
 * @public
 */
JSPraat.TextGrid.Tier.prototype.isPointTier = function() {
	if(this.header.classname === 'TextTier') {
		return true;
	}
	//... (maybe other tier types are also 'point tiers')
	return false;
};
/**
 * @method parseHeader
 * @private
 */
JSPraat.TextGrid.Tier.prototype.parseHeader = function() {
	var classnameRegex = /^\s+class\s*=\s*\"(\w+)\"/i;
	var nameRegex = /^\s+name\s*=\s*\"(\w+)\"/i;
	var xminRegex = /^\s+xmin\s*=\s*([\d\.]+)/i;
	var xmaxRegex = /^\s+xmax\s*=\s*([\d\.]+)/i;

	var intervalsSizeRegex = /^\s+intervals\:\s*size\s*=\s*(\d+)/i;
	var pointsSizeRegex = /^\s+points\:\s*size\s*=\s*(\d+)/i;
	var leadingSpaceRegex = /^(\s+)/;

	var match;
	var flagEndConditionReached = false;

	var size = null;
	for(var i = 0; i < this.lines.length; i++) {
		if ( (match = this.lines[i].match(intervalsSizeRegex)) ) {
			this.header.numberOfIntervals = size = parseInt(match[1]);
			flagEndConditionReached = true;
			this.startingLineIndexOfBody = i+1;
			break;
		}
		if ( (match = this.lines[i].match(pointsSizeRegex)) ) {
			this.header.numberOfPoints = size = parseInt(match[1]);
			flagEndConditionReached = true;
			this.startingLineIndexOfBody = i+1;
			break;
		}
		else
		if ( (match = this.lines[i].match(classnameRegex)) ) {
			this.header.classname = match[1];
		}
		else
		if ( (match = this.lines[i].match(nameRegex)) ) {
			this.header.name = match[1];
		}
		else
		if ( (match = this.lines[i].match(xminRegex)) ) {
			this.header.xmin = match[1];
		}
		else
		if ( (match = this.lines[i].match(xmaxRegex)) ) {
			this.header.xmax = match[1];
		}
	}

	if(!flagEndConditionReached && size > 0) {
		throw "Invalid Tier Header: end condition not reached while size is non-zero";
	}
};
/**
 * @method parseIntervals
 * @private
 */
JSPraat.TextGrid.Tier.prototype.parseIntervals = function() {
	if(this.header.numberOfIntervals === 0) { return; }

	// console.log('Parsing Intervals FROM ', this.startingLineIndexOfBody);
	// console.log(this.lines[this.startingLineIndexOfBody]);
	var i = this.startingLineIndexOfBody; 
	var topm, xmin, xmax, text;

	var intervalStartRegex = /^\s*intervals\s*\[\d+\]\:/i;
	var xmaxRegex = /^\s*xmax\s*\=\s*([\d\.]+)/i;
	var xminRegex = /^\s*xmin\s*\=\s*([\d\.]+)/i;
	var textRegex = /^\s*text\s*\=\s*\"(.*)\"/i;

	while(i < this.lines.length) {
		topm = this.lines[i++]; if(i >= this.lines.length) { throw "Invalid Tier Body: incomplete interval 0"; }
		xmin = this.lines[i++]; if(i >= this.lines.length) { throw "Invalid Tier Body: incomplete interval 1"; }
		xmax = this.lines[i++]; if(i >= this.lines.length) { throw "Invalid Tier Body: incomplete interval 2"; }
		text = this.lines[i++];

		if( (match = topm.match(intervalStartRegex)) ) {
		} else {
			throw "Invalid Tier Body: Invalid interval start format, expecting 'intervals [<digit>]:'";
		}

		if( (match = xmax.match(xmaxRegex)) ){ xmax = parseFloat(match[1]); } 
		else { throw "Invalid Tier Body: Invalid 'xmax' format";   }

		if( (match = xmin.match(xminRegex)) ) { xmin = parseFloat(match[1]);
		} else { throw "Invalid Tier Body: Invalid 'xmin' format"; }

		if( (match=text.match(textRegex)) ) { text = match[1];
		} else { throw "Invalid Tier Body: Invalid 'text' format"; }

		// this.intervals.push({'xmin': xmin, 'xmax': xmax, 'text': text});
		this.intervals.push([xmin, xmax, text]);

	}
	if(i < this.lines.length) { throw "Invalid Tier Body: incomplete interval remains"; }
};
/**
 * @method parsePoints
 * @private
 */
JSPraat.TextGrid.Tier.prototype.parsePoints = function() {
	if(this.header.numberOfPoints === 0) { return; }
	// console.log('Parsing Intervals FROM ', this.startingLineIndexOfBody);

	var pointStartRegex = /\s*points\s*\[\d+\]\:/i;
	var numberRegex = /^\s*number\s*\=\s*([\d\.]+)/i;
	var markRegex = /^\s*mark\s*\=\s*\"(.*)\"/i;

	var topm, number, mark;
	for(var i = this.startingLineIndexOfBody; i < this.lines.length; i++) {
		topm = this.lines[i++]; 	if(i >= this.lines.length) { throw "Invalid Tier Body: incomplete point 0"; }
		number = this.lines[i++];	if(i >= this.lines.length) { throw "Invalid Tier Body: incomplete point 1"; }
		mark = this.lines[i++];

		if( (match = topm.match(pointStartRegex)) ) {
		} else {
			throw "Invalid Tier Body: Invalid point start format, expecting 'points [<digit>]:'";
		}

		if( (match = number.match(numberRegex)) ){ number = parseFloat(match[1]); } 
		else { throw "Invalid Tier Body: Invalid 'number' format";   }

		if( (match=mark.match(markRegex)) ) { mark = match[1];
		} else { throw "Invalid Tier Body: Invalid 'mark' format"; }

		// this.points.push({'number': number, 'mark': mark});
		this.points.push([number, mark]);
	}
};

//------------------------------------------------------------------------------------------------------
//--------------------------------END OF TEXTGRID/TIER--------------------------------------------------
//------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------
//--------------------------------END OF TEXTGRID-------------------------------------------------------
//------------------------------------------------------------------------------------------------------





//------------------------------------------------------------------------------------------------------
//--------------------------------START OF AUDIO--------------------------------------------------------
//------------------------------------------------------------------------------------------------------

/**
 * A wrapper class for all of our functions on Audio.
 * It works via the AudioContext;
 *
 * @class Audio
 * @memberOf JSPraat
 * @constructor
 * @param {string} url The url of the audio file
 * @param {function} readyFunc The ready function
 */
JSPraat.Audio = function(url, readyFunc) {
	if(! (this instanceof JSPraat.Audio)) {
		return new JSPraat.Audio.Audio(url);
	}
	console.log('constructing JSPraat.Audio...');
	var self = this;

	this.url = url;
	this.readyFunc = readyFunc;

	this.ctx = new AudioContext();

	this.audioBuffer = readyFunc;
	/*
	 * Properties of the audioBuffer
	 * - duration (in seconds)
	 * - gain (0-1)
	 * - length
	 * - numberOfChannels
	 * - sampleRate
	 */

	this.sourceNode = null;
	this.channelData = new Array();


	this.gainNode = null;
	this.gainValue = 1.0;

	this.analyserNode = null;
	this.jsNode = null;

	this.loadSound();

	console.log('constructing JSPraat.Audio...done');
};
//------START OF STATIC FUNCTIONS---------------------
/**
 * Calculates the average of an array. In this case for average volume.
 * It does not do type checking. It is meant to be used onaudioprocess.
 * @static
 * @param {Array} arr An array of summables and dividables
 * @method getAverageVolume
 */
JSPraat.Audio.getAverageVolume = function(arr) {
	var s = 0; var size = arr.length;
	for(var i = 0; i < size; i++) {
		s += arr[i];
		s /= 2;
	}
	return s;
};
//----------------------------------------------------
/**
 * findPeaks Calculate all {length} peaks in this audio buffer
 * @param {Integer} length The number of peaks to extract
 * @method findPeaks
 */
JSPraat.Audio.prototype.findPeaks = function(length) {
	var peaks = new Float32Array(length);
	var sampleSize = this.audioBuffer.length / length;
	var sampleStep = Math.floor(sampleStep / 10) || 1;

	for(var ch = 0; ch < this.audioBuffer.numberOfChannels; ++ch) {
		var data = this.channelData[ch];
		for(var i = 0; i < length; ++i) {
			var start = Math.floor(i*sampleSize);
			var end = Math.floor(start + sampleSize);
			var max = 0;
			for(var j = start; j < end; j += sampleStep) {
				var value = data[j];
				if(value > max)  { max = value; }
				else
				if(-value > max) { max = value; }
			}
			if(ch == 0 || max > peaks[i]) {
				peaks[i] = max;
			}
		}
	}
	return peaks;
};
/**
 * sets the ready function
 */
JSPraat.Audio.prototype.ready = function(func) {
	if(typeof func !== 'function') {
		throw "Audio: ready requires a function";
	}
	this.readyFunc = func;
};
/**
 * Creates and initializes all the nodes
 * @private
 * @method initNodes
 */
JSPraat.Audio.prototype.initNodes = function() {
	var self = this;
	console.log('initNodes...');


	// create the sourceNode
	this.sourceNode = this.ctx.createBufferSource();
	this.sourceNode.buffer = this.audioBuffer;
	this.playingTimeout = null;
	console.log('sourceNode = ', this.sourceNode);


	// create the gainNode
	this.gainNode = this.ctx.createGain();
	this.gainNode.connect(this.ctx.destination);
	this.gainNode.gain.value = this.gainValue;
	console.log('gainNode = ', this.gainNode);

	// create the analyserNode
	this.analyserNode = this.ctx.createAnalyser(); 
	this.analyserNode.smoothingTimeConstant = 0.3;
	this.analyserNode.fftSize = 1024;


	// create the jsNode
	this.jsNode = this.ctx.createScriptProcessor(2048, 2, 1);
	console.log('jsNode = ', this.jsNode);

	// this.jsNode.onaudioprocess = function() {
	// 	var array =  new Uint8Array(self.analyserNode.frequencyBinCount);
	// 	self.analyserNode.getByteFrequencyData(array);
		
	// 	var averageVolume = JSPraat.Audio.getAverageVolume(array);
	// 	console.log(averageVolume);
	// };

	this.connectNodes();

	console.log('initNodes...done');
};
/**
 * connectNodes connects all the nodes.
 * @private
 * @method connectNodes
 */
JSPraat.Audio.prototype.connectNodes = function() {
	// connect nodes
	// [sourceNode] -> [gainNode]    -> [destination]
	//       |
	//       +------> [analyserNode] -> [jsNode]

	this.sourceNode.connect(this.gainNode);
	this.sourceNode.connect(this.analyserNode);

	this.analyserNode.connect(this.jsNode);
	this.jsNode.connect(this.ctx.destination);
};
/**
 * loadSound loads the audio data, decodes
 * the data onload, and stores the buffer
 * for re-use.
 * @private
 * @method loadSound
 */
JSPraat.Audio.prototype.loadSound = function() {
	console.log('loading sound from: ' + this.url);
	var self = this;
	var req = new XMLHttpRequest();
	req.open('GET', this.url, true);
	req.responseType = 'arraybuffer';

	req.onload = function() {
		self.ctx.decodeAudioData(req.response, function(buf) {
			self.audioBuffer = buf;
			self.initNodes();

			for(var i = 0; i < self.audioBuffer.numberOfChannels; ++i) {
				self.channelData.push(self.audioBuffer.getChannelData(i));
			}
			
			if(typeof self.readyFunc === 'function') {
				self.readyFunc();
			}
		}, self.onError);
	};
	req.send();
};
JSPraat.Audio.prototype.recreateSourceNode = function() {
	// create the sourceNode
	this.sourceNode = this.ctx.createBufferSource();
	this.sourceNode.buffer = this.audioBuffer;
	console.log('sourceNode = ', this.sourceNode);

	//re-connect the nodes
	this.connectNodes();
};
/**
 * stopPlay is called to stop what is currently playing
 * @method stopPlay
 */
JSPraat.Audio.prototype.stopPlay = function() {
	if(this.playingTimeout) {
		console.log('Audio: already playing something. Aborting current play:');

		window.clearTimeout(this.playingTimeout);
		this.playingTimeout = null;

		this.sourceNode.stop(0);
		this.recreateSourceNode();
	}
};

/**
 * playDuration takes a required start time and an optional
 * duration. The duration must be less than remaining time from
 * the start time.
 *
 * @method playDuration
 * @param {integer} start The start time in seconds
 * @param {integer} duration The duration in seconds
 */
JSPraat.Audio.prototype.playDuration = function(start, duration) {
	var self = this;

	if(start < 0 || start > self.audioBuffer.duration) {
		throw "Audio: playDuration requires 0 <= start <= duration";
	}
	var remaining = self.audioBuffer.duration - start;

	if(duration) {
		if(duration > remaining) {
			throw "Audio: playDuration requires duration <= remaining time";
		}
	} else {
		duration = remaining;
	}

	self.noteGrainOn(0, start, duration);
};
/**
 * playInterval takes a required start time and an optional
 * end time in seconds. It then plays the given interval
 * from the audio source node.
 * if no end time is given, it plays from the start time
 * all the way to the end of the buffer.
 *
 * @method playInterval
 * @param {integer} start The start time in seconds
 * @param {integer} end The end time in seconds
 */
JSPraat.Audio.prototype.playInterval = function(start, end) {
	console.log('playing sound [' +start+ ', ' +end+ ']');
	var duration, self = this;

	self.sourceNode.playbackRate.value = 1.0;

	if(start < 0 || start > self.audioBuffer.duration) {
		throw "Audio: playInterval requires 0 <= start <= duration";
	}

	if(end) {
		if(end < start || end > self.audioBuffer.duration) { 
			throw "Audio: playInterval requires start <= end <= duration";
		}
		// play immediately in the interval from start to end
		duration = (end-start);
	} else {
		// play immediately all the way through
		duration = self.audioBuffer.duration - start;
	}

	self.noteGrainOn(0, start, duration);
};

/**
 * noteGrainOn wraps around sourceNode.noteGrainOn
 * It recreates the playingTimeout
 * @private
 * @method noteGrainOn
 */
JSPraat.Audio.prototype.noteGrainOn = function(delay, offset, duration) {
	var self = this;

	self.stopPlay(); //release the lock

	// noteGrainOn takes (delay, offset, duration)
	console.log(self.sourceNode);
	// self.sourceNode.noteGrainOn(0, offset, duration);
	self.sourceNode.start(0, offset, duration);

	// self.sourceNode.play(0, offset, duration);

	self.playingTimeout = window.setTimeout(function() {
		console.log('Audio: play finished. recreating source node.');
		self.recreateSourceNode();
		self.playingTimeout = null;
	}, 1000*duration);
	console.log('playingTimeout = ', self.playingTimeout);
}
JSPraat.Audio.prototype.onError = function(e) {
	console.log(e);
	throw "Audio: error decoding audio data. ";
};
//------------------------------------------------------------------------------------------------------
//--------------------------------END OF AUDIO----------------------------------------------------------
//------------------------------------------------------------------------------------------------------







//------------------------------------------------------------------------------------------------------
//--------------------------------START OF TIME-SYNCED-GRID---------------------------------------------
//------------------------------------------------------------------------------------------------------

/**
 * A TimeSyncedGrid displays exactly one WAV form
 * time-synchronized to exactly one TextGrid below the WAV form.
 *
 * @class TimeSyncedGrid
 * @memberOf JSPraat
 * @constructor
 * @param {string} ID of the container for the TimeSyncedGrid
 */
JSPraat.TimeSyncedGrid = function($container) {
	if(! (this instanceof JSPraat.TimeSyncedGrid)) {
		return new JSPraat.TimeSyncedGrid($container);
	}
	if(! ($container instanceof jQuery)) {
		throw "TimeSyncedGrid: container must be a jQuery object";
	}
	if($container.length == 0) {
		throw "TimeSyncedGrid: container does not exist";
	}
	this.zoomFactor = 20;
	this.xmultMin = 100;
	this.xmultMax = 800;
	this.xmult = this.xmultMin + (this.xmultMax - this.xmultMin) / 2;
	this.timePrecision = 3;

	this.cPrefix = "TSG";
	this.currentTime = 0.0;

	this.currentTimeMarkerPosition = null;
	this.tierNameOffset = null;

	this.c = {
		'width': null,
		'height': null,
		'$': $container,
		'scroller': {
			'cn': this.cPrefix + '-scroller',
			'$': null,
			'pos': 0,
			'audioWrapper': {
				'cn': this.cPrefix + '-audio-wrapper',
				'$': null,
				'z': null,
				'ctx': null,
				'height': 101
			},
			'audioWrapper2': {
				'cn': this.cPrefix + '-audio-wrapper2',
				'$': null,
				'z': null,
				'ctx': null,
			},
			'textgridWrapper': {
				'cn': this.cPrefix + '-textgrid-wrapper',
				'$': null
			},
		},
		'infotop': {
			'cn': this.cPrefix + '-infotop',
			'$': null,
			'timeData': {
				'cn': this.cPrefix + '-infotop-time-data',
				'$': null,
			},
			'currentWindow': {
				'cn': this.cPrefix + '-infotop-current-window',
				'$': null
			},
			'currentTime': {
				'cn': this.cPrefix + '-current-time',
				'$': null,
			},
			'controls': {
				'cn': this.cPrefix + '-controls',
				'$': null,
				'zoomIn': {
					'cn': this.cPrefix + '-controls-zoom-in',
					'$': null
				},
				'zoomOut': {
					'cn': this.cPrefix + '-controls-zoom-out',
					'$': null
				},
				'zoomSlider': {
					'cn': this.cPrefix + '-controls-zoom-slider',
					'$': null
				},
				'zoomIndicator': {
					'cn': this.cPrefix + '-controls-zoom-indicator',
					'$': null
				}
			}
		},
		'label': {
			'cn': this.cPrefix + '-label',
			'$': null,
		},
		'tiers': {
			'className': this.cPrefix+'-tier',
			's': '.'+ this.cPrefix +'-tier',
			'floatersVisible': false,
			'tierNameOffset': null,
			'nfo': {}
		},
	};

	this.initializeUI();

	this.textgrid = null;
	this.audio = null;
};
/**
 * Create all UI Elements
 * @method initializeUI
 * @private
 */
JSPraat.TimeSyncedGrid.prototype.initializeUI = function() {
	var self = this;

	this.c.$.html("<div class='"+this.c.scroller.cn+"'></div>");
	this.c.scroller.$ = this.c.$.find('.'+this.c.scroller.cn);

	this.c.$.prepend("<div class='"+this.c.label.cn+"'></div>");
	this.c.label.$ = this.c.$.find('.'+this.c.label.cn);

	this.c.$.prepend("<div class='"+this.c.infotop.cn+"'></div>");
	this.c.infotop.$ = this.c.$.find('.'+this.c.infotop.cn);

	this.c.infotop.$.prepend("<span class='"+this.c.infotop.currentWindow.cn+"'></span>");
	this.c.infotop.currentWindow.$ = this.c.infotop.$.find('.'+this.c.infotop.currentWindow.cn);
	this.c.infotop.currentWindow.$.attr('title', 'Current Time Window');
	this.c.infotop.currentWindow.$.text('-');

	this.c.infotop.$.prepend("<span class='"+this.c.infotop.timeData.cn+"'></span>");
	this.c.infotop.timeData.$ = this.c.infotop.$.find('.'+this.c.infotop.timeData.cn);
	

	this.c.infotop.$.append("<span class='"+this.c.infotop.currentTime.cn+"'></span>");
	this.c.infotop.currentTime.$ = this.c.infotop.$.find('.'+this.c.infotop.currentTime.cn);
	this.c.infotop.currentTime.$.text('-');

	this.c.infotop.$.prepend("<span class='"+this.c.infotop.controls.cn+"'></span>");
	this.c.infotop.controls.$ = this.c.infotop.$.find('.'+this.c.infotop.controls.cn);

	this.c.infotop.controls.$.append("<span class='control-btn "+this.c.infotop.controls.zoomIn.ID+"' data-name='zoomIn'><i class='fa fa-fw fa-search-plus'></i></span>");
	this.c.infotop.controls.zoomIn.$ = this.c.infotop.controls.$.find('.'+this.c.infotop.controls.zoomIn.cn);

	this.c.infotop.controls.$.append("<span class='control-btn "+this.c.infotop.controls.zoomOut.ID+"' data-name='zoomOut'><i class='fa fa-fw fa-search-minus'></i></span>");
	this.c.infotop.controls.zoomOut.$ = this.c.infotop.controls.$.find('.'+this.c.infotop.controls.zoomOut.cn);

	this.c.infotop.controls.$.append('<input type="range" name="points" min="'+this.xmultMin+'" max="'+this.xmultMax+'" class="'+this.c.infotop.controls.zoomSlider.cn+'">');
	this.c.infotop.controls.zoomSlider.$ = this.c.infotop.controls.$.find('.'+this.c.infotop.controls.zoomSlider.cn);

	this.c.infotop.controls.zoomSlider.$.on('change', function(e) {
		self.xmult = parseInt($(this).val());
		self.render();
	});

	this.c.infotop.controls.$.append('<span class="'+this.c.infotop.controls.zoomIndicator.cn+'">'+this.xmult+'</span>');
	this.c.infotop.controls.zoomIndicator.$ = this.c.infotop.controls.$.find('.'+this.c.infotop.controls.zoomIndicator.cn);


	//create textgrid-wrapper
	this.c.scroller.$.append('<div class="'+this.c.scroller.textgridWrapper.cn+'"></div>');
	this.c.scroller.textgridWrapper.$ = this.c.scroller.$.find('.'+this.c.scroller.textgridWrapper.cn);

	//create audio-wrapper
	this.c.scroller.$.prepend('<canvas class="'+this.c.scroller.audioWrapper.cn+'"></canvas>');
	this.c.scroller.audioWrapper.$ = this.c.scroller.$.find('.'+this.c.scroller.audioWrapper.cn);
	this.c.scroller.audioWrapper.z = this.c.scroller.audioWrapper.$.get(0);

	//create audio-wrapper2
	this.c.scroller.$.prepend('<canvas class="'+this.c.scroller.audioWrapper2.cn+'"></canvas>');
	this.c.scroller.audioWrapper2.$ = this.c.scroller.$.find('.'+this.c.scroller.audioWrapper2.cn);
	this.c.scroller.audioWrapper2.z = this.c.scroller.audioWrapper2.$.get(0);

	this.c.scroller.$.on('scroll', function(e) {
		if(!self.tierNameOffset) { return; }
		var x = $(this).scrollLeft();
		var $floaters = self.c.scroller.$.find('.tier-name-floater');

		// $floaters.stop(true, true).animate({'opacity': ((x > self.tierNameOffset) ? 1 : 0)}, 200);
		if(x >= self.tierNameOffset && !self.c.tiers.floatersVisible) {
				$floaters.stop(true, true).animate({'opacity': 1}, 200);
				self.c.tiers.floatersVisible = true;
		}
		else
		if(x < self.tierNameOffset && self.c.tiers.floatersVisible) {
			$floaters.stop(true, true).animate({'opacity': 0}, 200);
			self.c.tiers.floatersVisible = false;
		}

		// not optimal but looks nicer to always move it
		for(var k in self.c.tiers.nfo) {
			self.c.tiers.nfo[k].nameFloater
			.transition()
			.duration(700)
			.attr('transform', 'translate('+x+', 0)');
		}

		if(self.audio) {
			self.updateTimeMarkerAudio();	
		}
		self.updateTimeWindow();
	});

	this.c.scroller.$.mousewheel(function(e, delta) {
		var currentScroll = self.c.scroller.$.scrollLeft();
		self.c.scroller.$.scrollLeft(currentScroll - 10*delta);
		self.updateTimeWindow();
		return false;
	});

	this.c.infotop.controls.$.find('.control-btn').each(function(e) {
		$(this).on('click', function(e) {
			var name = $(this).data('name');	
			var func = self['controlsEventHandler_'+name+'_click'];
			if(typeof func !== 'function') { return; }
			func.call(self, e);
		});
	});

	this.updateZoomControls();
};
JSPraat.TimeSyncedGrid.prototype.updateTimeWindow = function() {
	var self = this;
	var $scroller = self.c.scroller.$;
	var $timeWindow = self.c.infotop.currentWindow.$;

	var leftTime = Math.round(self.mapTierPositionToTime(1)*1000) / 1000;
	var scrollerWidth = self.c.scroller.$.width() - 1;
	var rightTime = Math.round(self.mapTierPositionToTime(scrollerWidth)*1000) / 1000;


	self.c.scroller.audioWrapper.leftTime = leftTime;
	self.c.scroller.audioWrapper.rightTime = rightTime;
	self.c.scroller.audioWrapper.timeWindow = rightTime - leftTime;

	$timeWindow.text(leftTime + ", " + rightTime + ", " + (Math.round( (self.c.scroller.audioWrapper.timeWindow)*1000 ) / 1000) );

	if(self.audio) {
		self.renderAudioWindow();	
	}
};
JSPraat.TimeSyncedGrid.prototype.updateZoomControls = function() {
	var self = this;
	this.c.infotop.controls.zoomIndicator.$.text( Math.round((this.xmult - this.xmultMin) / (this.xmultMax - this.xmultMin) * 100) );
	this.c.infotop.controls.zoomSlider.$.val(this.xmult);

	var scrollLeft = this.c.scroller.$.scrollLeft();
	window.setTimeout(function() {
		self.updateTimeWindow();
	}, 500);
}
JSPraat.TimeSyncedGrid.prototype.controlsEventHandler_zoomIn_click = function(e) {
	console.log('TimeSyncedGrid Event: zoomIn');
	this.xmult += this.zoomFactor;
	this.render();
};
JSPraat.TimeSyncedGrid.prototype.controlsEventHandler_zoomOut_click = function(e) {
	console.log('TimeSyncedGrid Event: zoomOut');
	var newMult = this.xmult - this.zoomFactor;
	if(newMult < this.xmultMin) { return; }
	this.xmult = newMult;
	this.render();
};
/**
 * Sets the TextGrid to display in this TimeSyncedGrid
 * The TextGrid is then immediately rendered.
 * The TextGrid must be ready to render, to ensure this:
 * call this function within 
 * myTextGrid.ready(function() {...})
 * @method setTextGrid
 * @param {JSPraat.TextGrid} tgrid A TextGrid object that is ready for rendering.
 */
JSPraat.TimeSyncedGrid.prototype.setTextGrid = function(tgrid) {
	this.textgrid = tgrid;
	this.render();
};
/**
 * Sets the JSPraat.Audio object to display in this TimeSyncedGrid
 * The Audio object is then immediately rendered. 
 * The Audio object must be ready to render, to ensure this:
 * call this function within myAudio.ready(function() {...})
 */
JSPraat.TimeSyncedGrid.prototype.setAudio = function(audio) {
	this.audio = audio;
	this.render();
};

/**
 * Reshapes this TimeSyncedGrid.
 * This is called usually after zooming.
 * THIS METHOD IS UNFINISHED
 * @method reshape
 */
JSPraat.TimeSyncedGrid.prototype.reshape = function() {
	console.log('reshaping...');
	var self = this;

	var pTimeMarkerOffset = 0;
	var cTimeMarkerOffset = 0;
	var dTimeMarkerOffset = 0;

	for(var k in this.c.tiers.nfo) {
		pTimeMarkerOffset = $(this.c.tiers.nfo[k].timeMarker[0][0]).offset().left;
		break;
	}

	this.c.scroller.pos = this.c.scroller.$.scrollLeft();

	//--- ReShape TextGrid ---
	var tierNameOffset = self.c.tiers.tierNameOffset;
	self.c.scroller.$.find('svg').each(function(e) {
		var tierHeight = $(this).height();
		var halfTierHeight = tierHeight / 2;
		var quarterTierHeight = halfTierHeight / 4;

		var tierData = d3.select(this).data()[0];
		var isIntervalTier = tierData.isIntervalTier();
		$(this).find('g').each(function(e) {
			var $el = $(this);
			var d = d3.select(this).data();
			if(typeof d[0][0] === 'undefined') { return; }
			d = d[0];

			$el
			.attr('transform', 'translate(' + (tierNameOffset + self.xmult*d[0]) + ', ' + (quarterTierHeight) + ')');

			if(isIntervalTier) {
				$el.find('rect')
				.attr('width', (self.xmult * d[1]) - (self.xmult * d[0]) - 1)
				.attr('height', halfTierHeight);
			}
			
		});
	});
	//--- Done Reshaping TextGrid

	this.updateZoomControls();
	this.updateTimeMarker();

	cTimeMarkerOffset = $(this.c.tiers.nfo[Object.keys(this.c.tiers.nfo)[0]].timeMarker[0][0]).offset().left;
	dTimeMarkerOffset = cTimeMarkerOffset - pTimeMarkerOffset;
	
	if(pTimeMarkerOffset) { this.c.scroller.$.scrollLeft(this.c.scroller.pos + dTimeMarkerOffset);}
}
/**
 * Renders this TimeSyncedGrid
 * @method render
 */
JSPraat.TimeSyncedGrid.prototype.render = function() {
	var self = this;
	this.c.width = this.c.$.innerWidth();
	this.c.height = this.c.$.innerHeight();

	var pTimeMarkerOffset = 0;
	var cTimeMarkerOffset = 0;
	var dTimeMarkerOffset = 0;

	for(var k in this.c.tiers.nfo) {
		pTimeMarkerOffset = $(this.c.tiers.nfo[k].timeMarker[0][0]).offset().left;
		break;
	}

	this.c.scroller.pos = this.c.scroller.$.scrollLeft();

	if(this.textgrid)	{ this.renderTextGrid();	}
	if(this.audio) { 
		this.c.scroller.audioWrapper.$.show();
		this.c.scroller.audioWrapper2.$.show();
		this.renderAudio();
	} else {
		this.c.scroller.audioWrapper.$.hide();
		this.c.scroller.audioWrapper2.$.hide();
	}

	this.c.scroller.$.scrollLeft(this.c.scroller.pos);

	this.updateZoomControls();
	this.updateTimeMarker();

	cTimeMarkerOffset = $(this.c.tiers.nfo[Object.keys(this.c.tiers.nfo)[0]].timeMarker[0][0]).offset().left;
	dTimeMarkerOffset = cTimeMarkerOffset - pTimeMarkerOffset;
	
	if(pTimeMarkerOffset) { this.c.scroller.$.scrollLeft(this.c.scroller.pos + dTimeMarkerOffset);}

	$(window).on('resize', function(e) {
		self.onWindowResize.apply(self, e);
	});
};
/**
 * Render the TextGrid for this TimeSyncedGrid
 * @method renderTextGrid
 * @private
 */
JSPraat.TimeSyncedGrid.prototype.renderTextGrid = function() {
	console.log('rendering textgrid');

	var self = this;

	var xmaxTier = Math.ceil(self.textgrid.header.xmax);
	var tierHeight = null;

	if(this.textgrid === null) { throw "TimeSyncedGrid: renderTextGrid found no textgrid"; }
	

	this.xmin = this.textgrid.header.xmin;
	this.xmax = this.textgrid.header.xmax;

	this.c.scroller.textgridWrapper.$.html('');
	var tiers = d3.select(this.c.scroller.textgridWrapper.$.get(0))
	.selectAll("div").data(this.textgrid.tiers)
	.enter()
	.append("div")
	.attr('class', function(d) {
		return self.c.tiers.className + " " + ( d.isIntervalTier() ? 'interval-tier' : 'point-tier' );
	})
	.attr('data-height', function(d) {
		return $(this).height();
	})
	.append("svg")
	.attr('height', function() {
		return (tierHeight = $(this).parent().height());
	})
	.attr('width', function() {
		return  self.xmult * xmaxTier;
	});
	var halfTierHeight = tierHeight / 2;

	var rTiers = tiers[0];
	var tierNameOffset = 0;
	for(var i = 0; i < rTiers.length; i++) {
		var name = rTiers[i].__data__.header.name
		if(name.length > tierNameOffset) { tierNameOffset = name.length; }
	}
	tierNameOffset*=10;
	self.c.tiers.tierNameOffset = tierNameOffset;

	for(var i = 0; i < rTiers.length; i++) {
		var svg = rTiers[i];
		var data = svg.__data__;
		var d3svg = d3.select(svg);

		var tierNameBox = d3svg
			.append('rect')
			.attr('height', halfTierHeight)
			.attr('width', tierNameOffset)
			.attr('x', 0)
			.attr('y', halfTierHeight/2)
			.attr('class', 'tier-name-box')
			.attr('title', data.header.name);

		var tierNameText = d3svg
			.append('text')
			.attr('height', halfTierHeight)
			.attr('width', tierNameOffset)
			.attr('x', 0)
			.attr('y', halfTierHeight/2)
			.attr('dy', halfTierHeight/1.5)
			.attr('dx', 2)
			.attr('class', 'tier-name-text')
			.text(data.header.name);

		var groups = null;

		if(data.isIntervalTier()) {
			groups = d3svg
			.selectAll('g').data(data.intervals)
			.enter()
			.append('g')
			.attr('transform', function(d, i) {
				return "translate("+ (tierNameOffset + self.xmult*d[0]) + ", " + (halfTierHeight / 2) + ")";
			})
			.attr('width', function(d) {
				return (self.xmult * d[1]) - (self.xmult * d[0]) - 1;
			})
			.attr('height', halfTierHeight)
			.attr('class', 'interval-group')
			.on('mouseenter', function(d) {
				self.c.infotop.timeData.$.text(d[0].toFixed(self.timePrecision)+ ", " + d[1].toFixed(self.timePrecision));
				self.c.label.$.html(d[2]);
			})
			.on('mouseout', function(d) {
				
			})
			.on('click', function(d) {
				if(self.audio) {
					self.audio.playInterval(d[0], d[1]);
				}
			});

			groups
			.append('rect')
			.attr('height', halfTierHeight)
			.attr('width', function(d) {
				return (self.xmult * d[1]) - (self.xmult * d[0]) - 1;
			})
			.attr('x', 0)
			.attr('y', 0)
			.attr('class', 'interval-box')
			.attr('title', function(d) { return d[2]; });


			groups
			.append('text')
			.attr('x', 0)
			.attr('y', 0)
			.attr('dy', halfTierHeight/1.5)
			.attr('dx', 2)
			.text(function(d) {
				var tbox = $(this).prev();
				if((d[2].length*10) >= parseInt(tbox.attr('width'))) {
					tbox.attr('class', 'interval-box-too-small');
					return ""; 
				}
				return d[2];
			})
			.attr('class', 'tier-text');

		} /* end if */
		if(data.isPointTier()) {
			groups = d3svg
			.selectAll('g').data(data.points)
			.enter()
			.append('g')
			.attr('transform', function(d, i) {
				return "translate("+ (tierNameOffset + self.xmult*d[0]) + ", " + (halfTierHeight / 2) + ")";
			})
			.attr('width', 5)
			.attr('height', halfTierHeight)
			.attr('class', 'point-group')
			.on('mouseenter', function(d) {
				self.c.infotop.timeData.$.text(d[0].toFixed(self.timePrecision));
				self.c.label.$.text(d[1]);
			})
			.on('mouseout', function(d) {
				
			});

			groups
			.append('rect')
			.attr('height', halfTierHeight)
			.attr('width', function(d) {
				return 10 * d[1].length;
			})
			.attr('x', 0)
			.attr('y', 0)
			.attr('rx', 5)
			.attr('ry', 5)
			.attr('class', 'point-box');


			groups
			.append('text')
			.attr('x', 0)
			.attr('y', 0)
			.attr('dy', halfTierHeight/1.5)
			.attr('dx', 2)
			.text(function(d) {
				var tbox = $(this).prev();
				if((d[1].length*10) > parseInt(tbox.attr('width'))) {
					tbox.attr('class', 'interval-box-too-small');
					return "";
				}
				return d[1];
			})
			.attr('class', 'tier-text');
		} /* end if */


		// Draw currentTimeMarker
		var timeMarker = d3svg
		.append('rect')
		.attr('width', 1)
		.attr('height', tierHeight)
		.attr('x', self.currentTimeMarkerPosition)
		.attr('y', 0)
		.attr('class', 'current-time-marker');

		


		//Draw the tierFloater
		tierFloaterGroup = d3svg
		.append('g')
		.attr('transform', "translate("+0+","+0+")")
		.attr('width', tierNameOffset)
		.attr('height', halfTierHeight/2)
		.attr('class', 'tier-name-floater')

		tierFloaterGroup
		.append('rect')
		.attr('width', tierNameOffset)
		.attr('height', halfTierHeight/2);

		tierFloaterGroup
		.append('text')
		.attr('x', 0)
		.attr('y', 0)
		.attr('dy', halfTierHeight/2.5)
		.attr('dx', 2)
		.attr('class', 'tier-name-floater-text')
		.text(data.header.name);

		d3svg.attr('data-tier-name', data.header.name);
		self.c.tiers.nfo[data.header.name] = {
			'timeMarker': timeMarker,
			'nameFloater': tierFloaterGroup
		};

	} /* end for */


	self.c.tiers.tierNameOffset = tierNameOffset;
	self.c.scroller.$.find('svg').on('click', function(e) {
		self.currentTime = self.mapTierPositionToTime(e.pageX - self.c.scroller.$.position().left);
		self.updateTimeMarker();
	});

	self.tierNameOffset = tierNameOffset;
};
JSPraat.TimeSyncedGrid.prototype.mapTierPositionToTime = function(offset) { 
	var self = this;
	var tierNameOffset = self.c.tiers.tierNameOffset;

	var xPixels = self.c.scroller.$.scrollLeft() - tierNameOffset - 1;
	if(offset) { xPixels += offset; }
	if(xPixels < 0) { xPixels = 0; }

	return xPixels / self.xmult;
};
/**
 * Move the timeMarker for each tier to the currentTime
 * @method updateTimeMarker
 * @private
 */
JSPraat.TimeSyncedGrid.prototype.updateTimeMarker = function() {
	var self = this;
	self.currentTimeMarkerPosition = self.currentTime * self.xmult + self.c.tiers.tierNameOffset;

	for(var k in self.c.tiers.nfo) {
		var timeMarker = self.c.tiers.nfo[k].timeMarker;
		timeMarker
		.attr('x', self.currentTimeMarkerPosition);
	}
	this.c.infotop.currentTime.$.text(this.currentTime.toFixed(this.timePrecision));

	if(self.audio) {
		self.updateTimeMarkerAudio();	
	}
};
JSPraat.TimeSyncedGrid.prototype.updateTimeMarkerAudio = function() {
	var self = this;
	var ctx = self.c.scroller.audioWrapper2.ctx;
	if(!ctx) { return; }
	var scrollLeft = self.c.scroller.$.scrollLeft();
	var width = self.c.scroller.audioWrapper.z.width;
	var height = self.c.scroller.audioWrapper.z.height;
	var realWidth = self.c.scroller.audioWrapper2.z.width;

	var x = (self.currentTimeMarkerPosition+0.5 - scrollLeft) % realWidth;
	ctx.clearRect(0, 0, width, height);
	ctx.beginPath();
	ctx.moveTo(x, 0);
	ctx.lineTo(x, parseInt(self.c.scroller.audioWrapper.z.height));
	ctx.strokeStyle='rgba(255,0,0,0.5)';
	ctx.lineWidth=1.5;
	ctx.stroke();
}
/**
 * Handle a window resize event. Setup by self.render()
 * @method onWindowResize
 */
JSPraat.TimeSyncedGrid.prototype.onWindowResize = function() {
	var self = this;
	if(self.audio) {
		var height = self.c.scroller.audioWrapper.height;
		self.c.scroller.audioWrapper2.$.width(self.c.scroller.$.width());
		self.c.scroller.audioWrapper2.z.width = self.c.scroller.$.width();
		self.c.scroller.audioWrapper2.$.height(height);
		self.c.scroller.audioWrapper2.z.height = height;	
	}
};
/**
 * Render the the audio file for this TimeSyncedGrid
 * TODO
 * @method renderAudio
 * @private
 */
JSPraat.TimeSyncedGrid.prototype.renderAudio = function() {
	console.log('rendering Audio');
	var self = this;

	if(self.audio === null) { throw "TimeSyncedGrid: renderAudio found no audio"; }

	var tierNameOffset = this.c.tiers.tierNameOffset;

	// var xmax = self.textgrid.header.xmax;
	var duration = self.audio.audioBuffer.duration;
	console.log('duration = ', duration);
	var aWidth =  duration * self.xmult;
	var width = tierNameOffset + aWidth;
	// var width = 32767; //seems to be limit
	var height = self.c.scroller.audioWrapper.height;
	var halfHeight = height / 2;

	// self.c.scroller.audioWrapper.$.width(width);
	// self.c.scroller.audioWrapper.z.width = width;

	// Render only current width
	self.c.scroller.audioWrapper.$.width(self.c.scroller.$.width());
	self.c.scroller.audioWrapper.z.width = self.c.scroller.$.width();

	self.c.scroller.audioWrapper.z.style.position = 'relative';
	self.c.scroller.audioWrapper.z.style.left = '0px';



	self.c.scroller.audioWrapper.$.height(height);
	self.c.scroller.audioWrapper.z.height = height;


	var position = self.c.scroller.audioWrapper.$.position();
	self.c.scroller.audioWrapper2.z.style.position = 'absolute';
	self.c.scroller.audioWrapper2.z.style.top = position.top;
	self.c.scroller.audioWrapper2.z.style.left = position.left;

	self.c.scroller.audioWrapper2.$.width(self.c.scroller.$.width());
	self.c.scroller.audioWrapper2.z.width = self.c.scroller.$.width();
	self.c.scroller.audioWrapper2.$.height(height);
	self.c.scroller.audioWrapper2.z.height = height;

	


	// var pxPerSecond = aWidth / duration;
	// console.log('pxPerSecond = ', pxPerSecond);
	var numPeaks = aWidth;
	var peaks = self.audio.findPeaks(numPeaks);
	self.c.scroller.audioWrapper.peaks = peaks;
	console.log('peaks.length = ', peaks.length);
	
	// var ctx = self.c.scroller.audioWrapper.z.getContext('2d');
	// var magY = null;
	// // TO-DO: normalize 
	
	// ctx.beginPath();
	// for(var i = 0; i < peaks.length; ++i) {
	// 	magY = halfHeight * peaks[i];	

	// 	ctx.moveTo(tierNameOffset + i, halfHeight);
	// 	ctx.lineTo(tierNameOffset + i, halfHeight + magY );

	// 	ctx.moveTo(tierNameOffset + i, halfHeight);
	// 	ctx.lineTo(tierNameOffset + i, halfHeight - magY);


	// }
	// ctx.strokeStyle = 'rgba(0,0,100,0.7)';
	// ctx.lineWidth = 1;
	// ctx.stroke();


	self.updateTimeWindow();

	self.c.scroller.audioWrapper2.ctx = self.c.scroller.audioWrapper2.z.getContext('2d');
};
JSPraat.TimeSyncedGrid.prototype.renderAudioWindow = function() {
	var self = this;

	var tierNameOffset = this.c.tiers.tierNameOffset;
	var height = self.c.scroller.audioWrapper.height;
	var halfHeight = height / 2;

	var peaks = self.c.scroller.audioWrapper.peaks;
	var ctx = self.c.scroller.audioWrapper.z.getContext('2d');

	
	var duration = self.audio.audioBuffer.duration;
	var leftTime = self.c.scroller.audioWrapper.leftTime;
	var rightTime = self.c.scroller.audioWrapper.rightTime;

	var peakStart = ~~((leftTime/duration) * peaks.length);
	var peakEnd = ~~((rightTime/duration) * peaks.length);

	// console.log('leftTime = ', leftTime);
	// console.log('rightTime = ', rightTime);
	// console.log('peakStart = ', peakStart);
	// console.log('peakEnd = ', peakEnd);

	// peakStart = 500;
	// peakEnd = 1800;

	var scrollLeft = self.c.scroller.$.scrollLeft();
	// console.log(scrollLeft);

	self.c.scroller.audioWrapper.z.style.left = self.c.scroller.$.scrollLeft() + 'px';

	var offset = 0;
	if(scrollLeft < tierNameOffset) {
		offset = -scrollLeft;
	} else {
		offset = -tierNameOffset;
	}

	// Clear the canvas
	self.c.scroller.audioWrapper.z.width = self.c.scroller.audioWrapper.z.width;

	var magY = null;
	ctx.beginPath();

	for(var i = peakStart; i < peakEnd; ++i) {
		magY = halfHeight * peaks[i];
		ctx.moveTo(tierNameOffset + offset, halfHeight);
		ctx.lineTo(tierNameOffset + offset, halfHeight + magY );

		ctx.moveTo(tierNameOffset + offset, halfHeight);
		ctx.lineTo(tierNameOffset + offset, halfHeight - magY);

		++offset;
	}
	ctx.strokeStyle = 'rgba(0,0,100,0.7)';
	ctx.lineWidth = 1;
	ctx.stroke();

	self.c.scroller.audioWrapper.ctx = ctx;
};
JSPraat.TimeSyncedGrid.autoRender = function() {
	$('.TSG-container').each(function(e) {
		var $w = $(this);
		var tgridURL = $w.data('textgrid');
		var audioURL = $w.data('audio');

		var tsg = new JSPraat.TimeSyncedGrid($w);

		console.log('autoRender: TextGrid URL = ', tgridURL);
		if(tgridURL) {
			console.log('autoRender: creating TextGrid');
			var tgrid = new JSPraat.TextGrid(tgridURL, function() {
				tsg.setTextGrid(this);
			});
		}

		console.log('autoRender: Audio URL = ', audioURL);
		if(audioURL && !audioURL.match(/^\s+$/)) {
			console.log('autoRender: creating Audio');
			var audio = new JSPraat.Audio(audioURL, function() {
				console.log('READY!');
				tsg.setAudio(this);
			});
		}

		
	});
};
//------------------------------------------------------------------------------------------------------
//--------------------------------END OF TIME-SYNCED-GRID-----------------------------------------------
//------------------------------------------------------------------------------------------------------
